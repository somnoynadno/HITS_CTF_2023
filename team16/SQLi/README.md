# Blind-SQL Инъекция

## Описание

Автор: И.А. Волгин (furlupe)  
Название: Окупай SQLай  
Лицензия: MIT License  
Сложность: Hard  
Описание: эксплуатация БД путем осуществления boolean blind-sql инъекций для поиска флага  
Теги: web, sql  

## Легенда

В связи с недавними новостями, ФСБ попросила вас проверить одну из нишевых социальных сетей на предмет использования ее преступниками, в частности - педофилами.  
Т.к. владелец данной соц. сети, ООО "SadChunk", расположен в другой стране, в нашем запросе на просмотр истории сообщений и базы данных сети он отказал, в следствие чего вам придется использовать общедоступную API для установления факта пользования ею злоумшленниками.  
Все, что вам нужно найти - любое **сообщение** из любого **чата**, которое может подтвердить вышеуказанный факт. Важно учитывать, что преступники не станут обсуждать подобные вещи в каждом чате и скорее всего будут пользоваться отдельными, **секретными** чатами.
Из открытых источников, нам известно, что в качестве СУБД приложение использует PostgreSQL.  

## Флаг

HITS{child_predator}  
Лежит в переменной среды ASPNETCORE_FLAG

## Развертывание

`docker compose up` внутри папки сервиса (./SQLi)

## Решение

1. Всего доступен один запрос, который выводит список пользователей системы с их возрастами и который в качестве параметра принимает поле, по которому можно осуществить сортировку. Попробуем осуществить простую инъекцию, чтобы проверить наличие возможности осуществления оных:  

    ```sql
    (case when (select 1 = 1) then age end) asc, age desc
    ```

    Запрос проходит успешно и возвращает нам ответ, отсортированный по возрастанию поля Age. Поменяем условие на `select 1 = 0` и увидим, что теперь сортировка убывающая. Таким образом, мы видим, что мы можем задавать СУБД вопросы, на которые она сможет отвечать нам ДА (возрастающая сортировка) или НЕТ (убывающая).

2. В задании явно выделено слово ЧАТЫ, попробуем узнать, есть ли что-то похожее в БД:  

    ```sql
    (case when (select count(*) from information_schema.columns where table_name like '%chat%' and column_name like '%name%') > 0 then age end) asc, age desc
    ```  

    Сортировка возрастает, значит в БД точно есть таблица, название которой содержит слово 'Chat', которая помимо этого еще имеет аттрибут, название которого содержит 'Name'.

3. Зная примерное имя таблицы и ее аттрибута, можем угадать ее настоящее название: Chats, chats, Chat и т.п. (и аналогично с точным названием аттрибута: Name, ChatName, etc.)

4. Однако, сейчас мы нашли только то, что внутри БД существует таблица чатов, но ведь необходимо найти непосредственно сами сообщения внутри этих чатов. Возьмем запрос из п.3, и поменяем наше неравенство так, чтобы оно сравнивалось с 1: `...(select count(*) ...) > 1 ...`.  
Видим, что сортировка возрастает, значит существует еще одна таблица, содержащая 'Chat', которая скорее всего и представляет собой таблицу сообщений чата (не забудем найти ее полное имя и имя её поля для текста сообщения!).

5. Имея на руках всю нужную информацию (почти, надо бы найти названия аттрибутов, отвечающих за идентификацию сущностей, что опять же делается несложно), мы можем заняться поиском флага. Для начала необходимо найти название чата (аттр. Name у таблицы Chats, через оператор like): Secret, Secrets, etc.  
Теперь, все, что нам осталось сделать - это соединить три таблицы (сообщения-в-чатах и чаты), отфильтровать по имени и перебрать каждое сообщение:

    ```sql
    (case when (select SUBSTR(Value, 1, 1) from ChatMessages inner join Chats on ChatMessages.ChatId = Chats.Id where Name like '%secret%') = 'H'  then age end) asc, age desc
    ```

    В данном запросе, мы узнаем у БД, есть ли такое сообщение, которое начинается (`SUBSTR(Value, 1, 1)`) с буквы 'H'. Таким образом, меняя индекс во втором параметре SUBSTR и сравнивая вырезанную строку с каждой буквой известного алфавита (A-Z, a-z, 0-9, {, }, _), мы можем найти, из чего состоит флаг.  
    (Можно также осуществить бинарный поиск, сравнивая не на равенство с буквой, а на то, является ли ASCII-код полученной из SUBSTR буквы меньше\больше того или иного ASCII-кода буквы алфавита)
